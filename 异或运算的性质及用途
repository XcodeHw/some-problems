参与运算的两个值，如果两个相应bit位相同，则结果为0，否则为1。
即：
　　　0^0 = 0， 
      1^0 = 1， 
      0^1 = 1， 
      1^1 = 0
按位异或的3个特点:
(1) 0^0=0,0^1=1  0异或任何数＝任何数
(2) 1^0=1,1^1=0  1异或任何数－任何数取反
(3) 任何数异或自己＝把自己置0
按位异或的几个常见用途:
(1) 使某些特定的位翻转
    例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。
　　　　　  10100001^00000110 = 10100111

(2) 实现两个值的交换，而不必使用临时变量。
    例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：
　　　　a = a^b； 　　//a=10100111
　　　　b = b^a； 　　//b=10100001
　　　　a = a^b； 　　//a=00000110

(3) 在汇编语言中经常用于将变量置零：
    xor   a，a

(4) 快速判断两个值是否相等
    举例1: 判断两个整数a，b是否相等，则可通过下列语句实现：
        return ((a ^ b) == 0)
    
    举例2: Linux中最初的ipv6_addr_equal()函数的实现如下:
    static inline int ipv6_addr_equal(const struct in6_addr *a1, const struct in6_addr *a2)
    {
        return (a1->s6_addr32[0] == a2->s6_addr32[0] &&
            a1->s6_addr32[1] == a2->s6_addr32[1] &&
            a1->s6_addr32[2] == a2->s6_addr32[2] &&
            a1->s6_addr32[3] == a2->s6_addr32[3]);
    }
    
    可以利用按位异或实现快速比较, 最新的实现已经修改为:
    static inline int ipv6_addr_equal(const struct in6_addr *a1, const struct in6_addr *a2)
    {
    return (((a1->s6_addr32[0] ^ a2->s6_addr32[0]) |
        (a1->s6_addr32[1] ^ a2->s6_addr32[1]) |
        (a1->s6_addr32[2] ^ a2->s6_addr32[2]) |
        (a1->s6_addr32[3] ^ a2->s6_addr32[3])) == 0);
    }

5  应用通式:

对两个表达式执行按位异或。

result = expression1 ^ expression2

参数
result

任何变量。

expression1

任何表达式。

expression2

任何表达式。

说明
^ 运算符查看两个表达式的二进制表示法的值，并执行按位异或。该操作的结果如下所示：

0101     (expression1)1100     (expression2)----1001     (结果)当且仅当只有一个表达式的某位上为 1 时，结果的该位才为 1。否则结果的该位为 0。

只能用于整数


下面这个程序用到了“按位异或”运算符：

class E 
{ public static void main(String args[ ]) 
{ 
  char  a1='十' ,  a2='点' ,  a3='进' ,  a4='攻' ; 
  char secret='8' ; 
  a1=(char) (a1^secret); 
  a2=(char) (a2^secret); 
  a3=(char) (a3^secret); 
  a4=(char) (a4^secret); 
  System.out.println("密文:"+a1+a2+a3+a4); 
  a1=(char) (a1^secret); 
  a2=(char) (a2^secret); 
  a3=(char) (a3^secret); 
  a4=(char) (a4^secret); 
  System.out.println("原文:"+a1+a2+a3+a4); 
} 
}

就是加密啊解密啊

char类型,也就是字符类型实际上就是整形,就是数字.

计算机里面所有的信息都是整数,所有的整数都可以表示成二进制的,实际上计算机只认识二进制的. 
位运算就是二进制整数运算啦. 
两个数按位异或意思就是从个位开始,一位一位的比. 
如果两个数相应的位上一样,结果就是0,不一样就是1 
所以111^101=010 
那加密的过程就是逐个字符跟那个secret字符异或运算. 
解密的过程就是密文再跟同一个字符异或运算 
010^101=111 
至于为什么密文再次异或就变原文了,这个稍微想下就知道了..
异或运算符∧也称XOR运算符。它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真）。即0∧0＝0，0∧1＝1，1∧1＝0。

性质：

(1).与1异或会翻转

(2).与0异或保持不变

(3).一个数异或它本身等于0

(4).每一位的结果只与该位有关。

应用：

(1).使特定位翻转

假设有01110101，现在想让第一位，第三位翻转（最低位为第一位），只要异或00000101，得到01110000.

(2).交换两个值，不用临时变量

　　假如a＝3，b＝4。想将a和b的值互换，可以用以下赋值语句实现：

　　a＝a∧b;
　　b＝b∧a;
　　a=a∧b;

　　即等效于以下两步：

　　① 执行前两个赋值语句：“a＝a∧b;”和“b＝b∧a;”相当于b＝b∧(a∧b)。而b∧a∧b等于a∧b∧b。b∧b的结果为0，因为同一个数与本身相∧，结果必为0。因此b的值等于a∧0，即a，其值为3。

　　② 再执行第三个赋值语句：a＝a∧b。由于a的值等于(a∧b)，b的值等于(b∧a∧b)，因此，相当于a＝a∧b∧b∧a∧b，即a的值等于a∧a∧b∧b∧b，等于b。a得到b原来的值。

(3).a^b=c->a^c=b
